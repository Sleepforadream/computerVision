from common import *


# Нормализуем изображение для корректного распознания числа
def normalize_image(source, destination):
    # Считываем файл в объект
    image = cv2.imread(source)

    # Переводим это изображение в чёрно-белый формат
    image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Используем функцию threshold для пороговой обработки изображения,
    # при которой каждый пиксель становится черным или белым в зависимости от порогового значения.
    # Параметр cv2.THRESH_BINARY_INV указывает, что цвета инвертируются в результате обработки.
    # В данной реализации используем автоматический выбор порогового значения с помощью аргумента cv2.THRESH_OTSU
    retention, threshold = cv2.threshold(image, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)

    # Для нахождения контуров на обработанном изображении с помощью функции cv2.findContours()
    # используем аргументы cv2.RETR_EXTERNAL и cv2.CHAIN_APPROX_SIMPLE и ищем только внешние контуры
    contours, hierarchy = cv2.findContours(threshold, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Находим контур с наибольшей площадью из списка contours.
    # Функция max() принимает список объектов и дополнительно параметр key, указывающий на функцию,
    # извлекающую значение, используемое для сравнения элементов списка.
    # Здесь key = cv2.contourArea определяет, что сравнение элементов списка будет основано на площади контура.
    # Таким образом, переменная largest_contour будет содержать контур с наибольшей площадью из списка contours
    largest_contour = max(contours, key=cv2.contourArea)

    # В данной строке кода выполняем получение координат и размеров ограничивающего прямоугольника(bounding rectangle)
    # для контура, который был найден ранее и записан в переменную largest_contour.
    # Функция cv2.boundingRect() принимает контур в качестве аргумента и возвращает координаты(x, y)
    # левого верхнего угла прямоугольника, а также его ширину w и высоту h.
    # Значения x, y, w и h извлекаются из функции и присваиваются соответствующим переменным x, y, w, h.
    # Таким образом, переменная x будет содержать координату x левого верхнего угла ограничивающего прямоугольника,
    # переменная y - координату y левого верхнего угла ограничивающего прямоугольника,
    # переменная w - ширину ограничивающего прямоугольника, а переменная h - высоту ограничивающего прямоугольника
    x, y, w, h = cv2.boundingRect(largest_contour)

    # Выполняем операции изменения координат и размеров ограничивающего прямоугольника для увеличения его размеров
    # на tolerance пикселей с каждой из его сторон.
    # Задаём значение переменной tolerance - величину на которую увеличится каждая сторона ограничивающего прямоугольника.
    tolerance = 60
    # Значение координаты x левого верхнего угла ограничивающего прямоугольника уменьшается на tolerance,
    # тем самым сдвигая левый верхний угол влево на tolerance пикселей.
    x -= tolerance
    # Значение координаты y левого верхнего угла ограничивающего прямоугольника уменьшается на tolerance,
    # тем самым сдвигая левый верхний угол вверх на tolerance пикселей.
    y -= tolerance
    # Значение ширины ограничивающего прямоугольника увеличивается на 2 * tolerance.
    # Для увеличения ширины на tolerance пикселей слева и справа прибавляется tolerance пикселей к каждой из сторон.
    w += 2 * tolerance
    # Значение высоты ограничивающего прямоугольника увеличивается на 2 * tolerance.
    # Для увеличения высоты на tolerance пикселей сверху и снизу прибавляется tolerance пикселей к каждой из сторон.
    h += 2 * tolerance
    # Теперь ограничивающий прямоугольник имеет размеры w на h, а его левый верхний угол смещен на tolerance
    # пикселей влево и вверх относительно изначального ограничивающего прямоугольника.

    # Выполним рисование контура на изображении image, чтобы выделить найденный объект.
    # Cоздадим новое черное изображение, размеры которого совпадают с исходным изображенем, используем функцию zeros_like()
    image = np.zeros_like(image)
    # Используем функцию cv2.drawContours() для рисования контура на изображении image.
    # image - изображение, на котором нужно нарисовать контур.
    # [largest_contour] - список контуров, который нужно нарисовать.
    # В данном случае список содержит только один контур - наибольший контур, который был найден ранее и
    # сохранен в переменную largest_contour.
    # 0 - индекс контура в списке, который нужно нарисовать.
    # В данном случае это 0, так как список содержит только один контур, (255, 255, 255) - цвет контура.
    # В данном случае цвет белый, представленный в формате BGR(синий, зеленый, красный),
    # thickness = 15 - толщина линии контура в пикселях.
    cv2.drawContours(image, [largest_contour], 0, (255, 255, 255), thickness=15)

    # Инвертируем цвета изображения
    # Для инвертирования используем функцию cv2.bitwise_not(), которая принимает изображение в качестве аргумента и
    # изменяет значения цветовых каналов каждого пикселя на инвертированные.
    image = cv2.bitwise_not(image)

    # Выполняем изменение размера изображения. Сначала выделяем область интереса на исходном изображении image,
    # по координатам(x, y) верхнего левого угла прямоугольника области и ее ширине w и высоте h.
    # Для этого используется срез массива NumPy: image[y:y + h, x:x + w].
    # Этот срез возвращает часть исходного изображения, соответствующую заданной области интереса.
    # Затем используем функцию cv2.resize() для изменения размера выделенной области на 28 x28 пикселей.
    # Функция принимает несколько параметров: image[y:y + h, x:x + w] - область интереса на исходном изображении,
    # (28, 28) - требуемый размер для изменения области интереса, interpolation = cv2.INTER_AREA - метод интерполяции,
    # используемый для изменения размера изображения. Используем метод "cv2.INTER_AREA" для уменьшения размерности изображения.
    image = cv2.resize(image[y:y + h, x:x + w], (28, 28), interpolation=cv2.INTER_AREA)

    # Сохраняем изображение в файл по указанному пути destination
    cv2.imwrite(destination, image)

    return destination


model = Model()

# Создаём и обучаем модель на тренировочном наборе данных MNIST
# model.build_model()

# Сохраняем модель в файл
# model.save_model('model')

# Загружаем модель из файла
model.load_model('model')

# Тестируем обученную модель на тестовом элементе с индексом
# print(model.test(5999))

# Распознаём число на изображении с помощью обученной модели машинного обучения и выводим его в консоль.
# Попутно нормализуем его для этого с помощью метода normalize_image написанного выше.
# Принимаем 2 параметра, где первый - изображение, число на котором должно быть распознано,
# второй - результирующий файл, куда будет записан итоговый результат полученного числа
print(model.get_recognized_number(normalize_image('5.jpg', 'result.jpg')))
